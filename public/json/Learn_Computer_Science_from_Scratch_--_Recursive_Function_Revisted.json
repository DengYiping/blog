{"date": "2018-08-05 21:13", "md": "In a previous blog post, I mentioned a little bit of recursive function in Haskell, and about how they works.\n\nToday we are going deeper into recursive functions, especially in Haskell.\n\nA typical property of problems solvable by recursion is divide-and-conquer -- first divide the problem into its subproblems, then merge the result in a certain way.\n\nTo be more specific, we apply three steps at each level of recursion:\n\n*   > **Divide** the problem into a number of subproblems that are smaller instances of the same problem.\n\n*   > **Conquer** the subproblems by solving them recursively. If the subproblem sizes are small enough, however, just solve the subproblems in a straightforward manner.\n\n*   > **Combine** the solutions to the subproblems into the solution for the original problem\nLast time, I gave a example of recursive function in my blog -- Fibonacci function, today I will take it apart analyse it.\n\n```Haskell\n\n    fib :: Integer -> Integer\n    fib x\n      ' x < 1 = error \"n should be greater than 0\" \n      ' x == 1 = 1\n      ' x == 2 = 2\n      ' otherwise = fib (x - 1) + fib (x - 2)\n\n```\n\nHow do we **divide** the problem of finding the nth Fibonacci number?\n\nWe know that, by definition, a Fibonacci number is the sum of the previous two Fibonacci number. we break the problem into the subproblem, finding its previous two Fibonacci number.\n\nHow to **conquer** the problem?\n\nIf the subproblem is simple enough, it is straight forward, we have already know the 1st and 2nd Fibonacci number, just simply plug it in. (Of course, you can put more cases in the code.)\n\nIf it is not that simple, well, continue by solving its subproblem, of course.\n\nHow do we **combine** the solution?\n\nThis one is straight forward. Once we obtained the previous two Fibonacci number, we just summing them up and return the result.\n\nHowever, if I tell you that there are some problem in the code above, it might be kind of hard to see.\n\nIn our previous Fibonacci number function, Fibonacci number function is called multiple times on a single argument.\n\nFor example, if we want to calculate the 5th Fibonacci number -- _fib 5_, we will calculate  _fib 4_  and  _fib 3_. However, in the calculation of _fib 4_, we calculated _fib 2_ and again _fib 3_. Clearly, fib 3 is been calculated multiple times.\n\nTo generalize, the algorithm given above has a cubic order of growth -- with the size of input growing linearly, the time complexity, or the running time of the program, grows as it is a cubic function.\n\nTo solve this problem in the algorithm, we can either use memorization or introduce a new helper function. I will discuss it in the next blog post.", "title": "Learn Computer Science from Scratch -- Recursive Function Revisted"}