{"date": "2018-08-05 21:13", "md": "In functional world, there is C-style for and while loop, and everything is based on recursion. However, sometimes, recursive algorithms can leads to problems in efficiency and readability.</span>\r\n\r\nIn may functional programming language, and in the world of Big Data processing, we use a technique called MapReduce.\r\n\r\nIn map function,  the **first** argument of map function is a functor( you can think of it as a function)  that is defined on every element of the lists, and map it to the other data type. the **second** argument takes a lists. It will apply this function to every element of the lists, and return a new lists.\r\n\r\nExample: I want to twice the number in the lists, we can write down\r\n\r\n```Haskell\r\n\r\n    Prelude> let let = [1..]\r\n    Prelude> let lst2 = map (\\x-> x * 2) lst\r\n    Prelude> take 4 lst2\r\n    [2,4,6,8]\r\n    Prelude> take 4 lst\r\n    [1,2,3,4]\r\n\r\n```\r\nThis small piece code demonstrates that how map works in Haskell.\r\n\r\nMap function is extremely useful when you want to create a key-value pair. For example, we take the original set **lst** as the key, and the value is the elements in **lst2**, so how do we do that?\r\n\r\n```Haskell\r\n\r\n    Prelude> let lst3 = map (\\x -> (x, x * 2)) lst\r\n    Prelude> take 4 lst3\r\n    [(1,2),(2,4),(3,6),(4,8)]\r\n    Prelude> \r\n\r\n```\r\nSee, now it is actually a key-value pair.\r\n\r\nAnother useful technique in functional world is **reduce**: somehow combines the elements in the lists and formulate the results.\r\n\r\nImagine that we want to calculate the appearance of each character in a world. We first map each character into a key-value pair, with value of 1 for each character, and then we combine the one with the same key.\r\n\r\n```Haskell\r\n\r\n    import Data.List\r\n\r\n    -- Normal Reduce Function\r\n    rd :: (a -> a -> a) -> [a] -> a\r\n    rd _ [] = error \"the list to be reduced should not be empty\"\r\n    rd f (x:xs) = rdHelper x xs\r\n        where rdHelper a [] = a\r\n              rdHelper a (y:ys) = rdHelper (f a y) ys\r\n\r\n    -- Sort by the key\r\n    sortByKey :: Ord k => [(k, v)] -> [(k, v)]\r\n    sortByKey lst = sortBy keyCmp lst\r\n        where keyCmp x y = compare (fst x) (fst y)\r\n\r\n    -- Reduce by Key\r\n    rdByKey :: Eq k => (v -> v -> v) -> [(k,v)] -> [(k,v)]\r\n    rdByKey _ [] = []\r\n    rdByKey _ (x:[]) = [x]\r\n    rdByKey f (x:y:xs) = if sameKey x y then rdByKey f ([(combinePair f x y)] ++ xs) else ([x] ++ (rdByKey f ([y] ++ xs)))\r\n        where combinePair f x y = (fst x, f (snd x) (snd y)) \r\n              sameKey (k1, v1) (k2, v2) = k1 == k2\r\n\r\n```\r\nI write this short reduce by key function help you create this functionality.\r\nTo count the char, we simply do\r\n\r\n```Haskell\r\n\r\n    *Main> let s = \"asdfasdfasqewr\"\r\n    *Main> let countchar = rdByKey (+) . sortByKey . map (\\x -> (x, 1))\r\n    *Main> countchar s\r\n    [('a',3),('d',2),('e',1),('f',2),('q',1),('r',1),('s',3),('w',1)]\r\n\r\n```\r\nOnly three lines of code.", "title": "Learn Computer Science From Scratch -- Map and Reduce in Function world"}